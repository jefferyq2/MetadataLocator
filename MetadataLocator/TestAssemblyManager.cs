using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;

namespace MetadataLocator;

/// <summary>
/// Test assembly generation options
/// </summary>
[Flags]
enum TestAssemblyFlags {
	/// <summary>
	/// The number of assembly
	/// </summary>
	IndexMask = 0xFF,

	/// <summary>
	/// Load it from memory
	/// </summary>
	InMemory = 0x100,

	/// <summary>
	/// Use #- table stream
	/// </summary>
	Uncompressed = 0x200
}

/// <summary>
/// Assembly for <see cref="MetadataInfoImpl"/> test
/// </summary>
sealed class TestAssembly {
	public TestAssemblyFlags Flags { get; }

	public int Index => (int)(Flags & TestAssemblyFlags.IndexMask);

	public bool InMemory => (Flags & TestAssemblyFlags.InMemory) != 0;

	public bool Uncompressed => (Flags & TestAssemblyFlags.Uncompressed) != 0;

	public Assembly Assembly { get; }

	public Module Module { get; }

	public nuint ModuleHandle { get; }

	public TestAssembly(TestAssemblyFlags flags, Assembly assembly) {
		Flags = flags;
		Assembly = assembly ?? throw new ArgumentNullException(nameof(assembly));
		Module = assembly.ManifestModule;
		ModuleHandle = ReflectionHelpers.GetModuleHandle(assembly.ManifestModule);
	}
}

/// <summary>
/// Manager of <see cref="TestAssembly"/>
/// </summary>
sealed class TestAssemblyManager {
	const int CACHE_MAGIC = 2;
	// Update it if old cache format is invalid

	static readonly Dictionary<TestAssemblyFlags, TestAssembly> assemblies = new();

	/// <summary>
	/// Get a test assembly
	/// </summary>
	/// <param name="flags"></param>
	/// <returns></returns>
	public static TestAssembly GetAssembly(TestAssemblyFlags flags) {
		if (!assemblies.TryGetValue(flags, out var testAssembly)) {
			string path = GetOrCreateAssembly(flags);
			bool inMemory = (flags & TestAssemblyFlags.InMemory) != 0;
			var assembly = inMemory ? Assembly.Load(File.ReadAllBytes(path)) : Assembly.LoadFile(path);
			testAssembly = new TestAssembly(flags, assembly);
			assemblies.Add(flags, testAssembly);
		}
		return testAssembly;
	}

	static string GetOrCreateAssembly(TestAssemblyFlags flags) {
		var tempDirectory = Path.Combine(Path.GetTempPath(), $"MetadataLocator_{CACHE_MAGIC:X2}_{RuntimeEnvironment.Version}");
		if (!Directory.Exists(tempDirectory))
			Directory.CreateDirectory(tempDirectory);
		string cachePath = Path.Combine(tempDirectory, $"{(uint)flags:X8}.dll");

		if (File.Exists(cachePath))
			return cachePath;

		var rawAssembly = Decompress(data);

		ulong a = 0x5F5F5F5F5F5F5F5F;  // ________
		ulong b = FlagsToAscii(flags); // 00000000
		int c = ReplaceAll(rawAssembly, a, b);
		Debug2.Assert(c == 2);
		if ((flags & TestAssemblyFlags.Uncompressed) != 0)
			ConvertToUncompressed(rawAssembly);
		File.WriteAllBytes(cachePath, rawAssembly);
		return cachePath;
	}

	static unsafe ulong FlagsToAscii(TestAssemblyFlags flags) {
		var s = $"{(uint)flags:X8}";
		ulong n = 0;
		for (int i = 0; i < 8; i++)
			n |= (ulong)s[i] << (i * 8);
		return n;
	}

	static unsafe int ReplaceAll(byte[] data, ulong a, ulong b) {
		fixed (byte* p = data) {
			int count = 0;
			int length = data.Length - 7;
			for (int i = 0; i < length; i++) {
				if (*(ulong*)(p + i) == a) {
					*(ulong*)(p + i) = b;
					count++;
					i += 7;
				}
			}
			return count;
		}
	}

	static unsafe void ConvertToUncompressed(byte[] data) {
		fixed (byte* p = data) {
			int i = 0;
			int length = data.Length - 3;
			for (; i < length; i++) {
				if (*(uint*)(p + i) == 0x424A5342)
					break;
			}
			Debug2.Assert(i != data.Length);
			length = data.Length - 1;
			for (; i < length; i++) {
				if (*(ushort*)(p + i) == 0x7E23)
					break;
			}
			Debug2.Assert(i != data.Length);
			*(ushort*)(p + i) = 0x2D23;
		}
	}

	static byte[] Decompress(byte[] data) {
		var buffer = new List<byte>(data.Length * 2);
		for (int i = 0; i < data.Length; i++) {
			if (data[i] == 0xFF) {
				ushort count = (ushort)(data[i + 1] | (data[i + 2] << 8));
				if (count != 0xFFFF) {
					Debug2.Assert(count > 3);
					while (count-- > 0)
						buffer.Add(0x00);
				}
				else {
					buffer.Add(0xFF);
				}
				i += 2;
			}
			else {
				buffer.Add(data[i]);
			}
		}
		return buffer.ToArray();
	}

	static readonly byte[] data = new byte[] {
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0xB8, 0xFF, 0x07, 0x00, 0x40, 0xFF, 0x23, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
		0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
		0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
		0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0xFF, 0x07, 0x00, 0x50, 0x45, 0x00, 0x00,
		0x4C, 0x01, 0x02, 0x00, 0xA7, 0xC5, 0x04, 0x62, 0xFF, 0x08, 0x00, 0xE0, 0x00, 0x02, 0x21, 0x0B,
		0x01, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x06, 0x00, 0x1E, 0x22, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0xFF, 0x04, 0x00, 0x40, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x04, 0xFF, 0x07, 0x00, 0x04, 0xFF, 0x08, 0x00, 0x60, 0x00, 0x00, 0x00, 0x02,
		0xFF, 0x06, 0x00, 0x03, 0x00, 0x40, 0x85, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0xFF, 0x04, 0x00,
		0x10, 0x00, 0x00, 0x10, 0xFF, 0x06, 0x00, 0x10, 0xFF, 0x0B, 0x00, 0xCC, 0x21, 0x00, 0x00, 0x4F,
		0xFF, 0x1C, 0x00, 0x40, 0x00, 0x00, 0x0C, 0xFF, 0x34, 0x00, 0x20, 0x00, 0x00, 0x08, 0xFF, 0x0B,
		0x00, 0x08, 0x20, 0x00, 0x00, 0x48, 0xFF, 0x0B, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00,
		0x00, 0x24, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0xFF,
		0x0E, 0x00, 0x20, 0x00, 0x00, 0x60, 0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x0C, 0xFF,
		0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0xFF, 0x0E, 0x00, 0x40, 0x00,
		0x00, 0x42, 0xFF, 0x39, 0x00, 0x22, 0xFF, 0x06, 0x00, 0x48, 0x00, 0x00, 0x00, 0x02, 0x00, 0x05,
		0x00, 0x58, 0x20, 0x00, 0x00, 0x74, 0x01, 0x00, 0x00, 0x01, 0xFF, 0x37, 0x00, 0x1E, 0x02, 0x28,
		0x01, 0x00, 0x00, 0x0A, 0x2A, 0x42, 0x53, 0x4A, 0x42, 0x01, 0x00, 0x01, 0xFF, 0x05, 0x00, 0x0C,
		0x00, 0x00, 0x00, 0x76, 0x32, 0x2E, 0x30, 0x2E, 0x35, 0x30, 0x37, 0x32, 0x37, 0xFF, 0x04, 0x00,
		0x05, 0x00, 0x6C, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x23, 0x7E, 0x00, 0x00, 0x0C, 0x01,
		0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x23, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0xFF, 0x04,
		0x00, 0x4C, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x23, 0x55, 0x53, 0x00, 0x54, 0x01, 0x00,
		0x00, 0x10, 0x00, 0x00, 0x00, 0x23, 0x47, 0x55, 0x49, 0x44, 0x00, 0x00, 0x00, 0x64, 0x01, 0x00,
		0x00, 0x10, 0x00, 0x00, 0x00, 0x23, 0x42, 0x6C, 0x6F, 0x62, 0xFF, 0x07, 0x00, 0x02, 0x00, 0x00,
		0x01, 0x47, 0x04, 0x00, 0x00, 0x09, 0xFF, 0x04, 0x00, 0xFA, 0x01, 0x33, 0x00, 0x16, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x05, 0x00, 0x1E, 0x00, 0x01, 0xFF,
		0x05, 0x00, 0x06, 0x00, 0x11, 0x00, 0x0A, 0xFF, 0x05, 0x00, 0x01, 0xFF, 0x05, 0x00, 0x01, 0x00,
		0x01, 0x00, 0x01, 0x00, 0x10, 0x00, 0x34, 0x00, 0x34, 0x00, 0x05, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x50, 0x20, 0xFF, 0x04, 0x00, 0x86, 0x18, 0x18, 0x00, 0x01, 0x00, 0x01, 0x00, 0x09, 0x00, 0x18,
		0x00, 0x01, 0xFF, 0x13, 0x00, 0x36, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x0B, 0x00, 0x05, 0x00, 0x2B,
		0xFF, 0x08, 0x00, 0x3C, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x3E, 0x00, 0x53, 0x79, 0x73, 0x74,
		0x65, 0x6D, 0x00, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x2E, 0x63, 0x74, 0x6F, 0x72, 0x00,
		0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x6D, 0x73, 0x63,
		0x6F, 0x72, 0x6C, 0x69, 0x62, 0x00, 0x5F, 0x00, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F,
		0x00, 0x00, 0x00, 0x03, 0x20, 0xFF, 0x05, 0x00, 0x83, 0xBA, 0x7D, 0x5E, 0x24, 0xF6, 0x28, 0x4D,
		0x9C, 0xE0, 0x95, 0x2F, 0xF7, 0x42, 0xFE, 0xF4, 0x00, 0x03, 0x20, 0x00, 0x01, 0x08, 0xB7, 0x7A,
		0x5C, 0x56, 0x19, 0x34, 0xE0, 0x89, 0x00, 0x00, 0xF4, 0x21, 0xFF, 0x0A, 0x00, 0x0E, 0x22, 0x00,
		0x00, 0x00, 0x20, 0xFF, 0x17, 0x00, 0x22, 0xFF, 0x0C, 0x00, 0x5F, 0x43, 0x6F, 0x72, 0x44, 0x6C,
		0x6C, 0x4D, 0x61, 0x69, 0x6E, 0x00, 0x6D, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x65, 0x2E, 0x64, 0x6C,
		0x6C, 0xFF, 0x05, 0x00, 0xFF, 0xFF, 0xFF, 0x25, 0x00, 0x20, 0x40, 0xFF, 0xDE, 0x01, 0x20, 0x00,
		0x00, 0x0C, 0x00, 0x00, 0x00, 0x20, 0x32, 0xFF, 0xF6, 0x01
	};
}

//.assembly extern mscorlib
//{
//  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )
//  .ver 2:0:0:0
//}
//.assembly '________'
//{
//}
//.module '________.dll'
//.class public auto ansi beforefieldinit _._ extends [mscorlib]System.Object
//{
//  .method public hidebysig specialname rtspecialname instance void  .ctor() cil managed
//  {
//    .maxstack  8
//    IL_0000:  ldarg.0
//    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
//    IL_0006:  ret
//  }
//}

//static byte[] Compress(byte[] data) {
//	var buffer = new List<byte>(data.Length);
//	for (int i = 0; i < data.Length; i++) {
//		if (data[i] == 0) {
//			int count = CountZero(data, i);
//			i += count - 1;
//			if (count > 3) {
//				Debug2.Assert(count < 0xFFFF);
//				buffer.Add(0xFF);
//				buffer.Add((byte)count);
//				buffer.Add((byte)(count >> 8));
//			}
//			else {
//				while (count-- > 0)
//					buffer.Add(0x00);
//			}
//		}
//		else if (data[i] == 0xFF) {
//			buffer.Add(0xFF);
//			buffer.Add(0xFF);
//			buffer.Add(0xFF);
//		}
//		else {
//			buffer.Add(data[i]);
//		}
//	}
//	return buffer.ToArray();

//	static int CountZero(byte[] data, int index) {
//		int i = index;
//		for (; i < data.Length && data[i] == 0; i++) ;
//		return i - index;
//	}
//}
